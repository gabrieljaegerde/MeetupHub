import{S,V as D,a as _,T as Ue,E as z,c as w,e as Pe,B as ve,u as U,b as K,d as M,_ as l,f as ne,O as de,h as _e,i as we,j as Me,k as Be,l as Ne,m as Le,n as Fe,o as qe,p as Ve,q as $e,r as He,t as Ce,v as Re,w as We,x as Oe,y as C,z as pe,A as ze,C as q,D as Ke}from"./index-C95lO3Km.js";const xe={specVersion:M,specName:_,base58Prefix:K,decimals:U,tokenSymbol:_},Ee=S(xe),Z=ve(32),Ge=z({V0:l,V1:S({typeInformationTreeRoot:Z,extrinsicMetadataHash:Z,...xe})});z({bool:l,char:l,str:l,u8:l,u16:l,u32:l,u64:l,u128:l,u256:l,i8:l,i16:l,i32:l,i64:l,i128:l,i256:l});const A=z({bool:l,char:l,str:l,u8:l,u16:l,u32:l,u64:l,u128:l,u256:l,i8:l,i16:l,i32:l,i64:l,i128:l,i256:l,compactU8:l,compactU16:l,compactU32:l,compactU64:l,compactU128:l,compactU256:l,void:l,perId:ne}),fe=S({name:de(_),ty:A,typeName:de(_)}),Je=z({composite:D(fe),enumeration:S({name:_,fields:D(fe),index:ne}),sequence:A,array:S({len:M,typeParam:A}),tuple:D(A),bitSequence:S({numBytes:U,leastSignificantBitFirst:_e})}),Ie=S({path:D(_),typeDef:Je,typeId:ne}),Qe=D(Ie),j=S({version:U,addressTy:A,callTy:A,signatureTy:A,signedExtensions:D(S({identifier:_,includedInExtrinsic:A,includedInSignedData:A}))}),Xe=Pe(U[1],t=>({version:t&-129,signed:!!(t&128)})),Ye=Ue.dec(w[1],Xe,ve(1/0)[1]);S({leaves:Qe,leafIdxs:D(M),proofs:D(Z),extrinsic:j,info:Ee});const Ze=(t,e)=>{const n=new Set,o=s=>{if(n.has(s))return;const{tag:r,value:i}=e.get(s).def;switch(r){case"composite":if(!i.length)break;n.add(s),i.forEach(({type:c})=>{o(c)});break;case"variant":if(!i.length)break;n.add(s),i.forEach(({fields:c})=>{c.forEach(({type:u})=>{o(u)})});break;case"tuple":if(!i.length)break;n.add(s),i.forEach(o);break;case"sequence":n.add(s),o(i);break;case"array":n.add(s),o(i.type);break;case"bitSequence":n.add(s)}};o(t.extrinsic.call),o(t.extrinsic.address),o(t.extrinsic.signature),t.extrinsic.signedExtensions.forEach(({type:s,additionalSigned:r})=>{o(s),o(r)});const a=[...n].sort((s,r)=>s-r);return new Map(a.map((s,r)=>[s,r]))},je={u8:1,u16:2,u32:4,u64:8},et=(t,e,n,o)=>{const{def:{tag:a,value:s}}=t.get(o);switch(a){case"composite":return[{tag:a,value:s.map(r=>({name:r.name,typeName:r.typeName,ty:e(r.type)}))}];case"variant":return s.map(r=>({tag:"enumeration",value:{name:r.name,index:r.index,fields:r.fields.map(i=>({name:i.name,typeName:i.typeName,ty:e(i.type)}))}}));case"sequence":return[{tag:a,value:e(s)}];case"array":return[{tag:a,value:{len:s.len,typeParam:e(s.type)}}];case"tuple":return[{tag:a,value:s.map(e)}];case"bitSequence":{const r=n(s.bitStoreType),i=je[r];if(!i)throw new Error("Invalid primitive for BitSequence");const c=t.get(s.bitOrderType).path,u=c.includes("Lsb0");if(!u&&!c.includes("Msb0"))throw new Error("BitOrderType not recognized");return[{tag:"bitSequence",value:{numBytes:i,leastSignificantBitFirst:u}}]}}throw new Error(`FrameId(${o}) should have been filtered out`)},tt=(t,e,n,o)=>{const a=[];return[...e.entries()].forEach(([s,r])=>{const{path:i}=t.get(s);et(t,n,o,s).forEach(c=>{a.push({path:i,typeId:r,typeDef:c})})}),a.sort((s,r)=>{if(s.typeId!==r.typeId)return s.typeId-r.typeId;if(s.typeDef.tag!=="enumeration"||r.typeDef.tag!=="enumeration")throw new Error("Found two types with same id");return s.typeDef.value.index-r.typeDef.value.index}),a},nt=t=>{try{const{metadata:e}=we(t);if(e.tag!=="v15")throw new Error("Wrong metadata version");return e.value}catch(e){throw e||new Error("Unable to decode metadata")}},R=t=>{const e=t.length;let n=0;for(let a=0;a<e;a++)n+=t[a].byteLength;const o=new Uint8Array(n);for(let a=0,s=0;a<e;a++){const r=t[a];o.set(r,s),s+=r.byteLength}return o},ge=t=>typeof t=="string"?Me(t):t,st={null:"void",u8:"compactU8",u16:"compactU16",u32:"compactU32",u64:"compactU64",u128:"compactU128",u256:"compactU256"},rt={bool:U,char:U,str:_,u8:U,u16:K,u32:M,u64:Re,u128:Ce,u256:He,i8:$e,i16:Ve,i32:qe,i64:Fe,i128:Le,i256:Ne,void:l,compactU8:w,compactU16:w,compactU32:w,compactU64:w,compactU128:w,compactU256:w},Se=(t,e,n,o,a)=>{if(e.tag!=="perId"){rt[e.tag][1](t);return}const s=u=>{Se(t,u,n,o,a)},r=n.get(e.value),[i]=r,c=o[i];switch(r.length===1&&a.add(i),c.typeDef.tag){case"enumeration":{const u=U.dec(t),[h,m]=r.map(f=>[o[f].typeDef,f]).find(([f])=>f.value.index===u);a.add(m),h.value.fields.forEach(({ty:f})=>{s(f)});break}case"sequence":{const u=w.dec(t);for(let h=0;h<u;h++)s(c.typeDef.value);break}case"array":{for(let u=0;u<c.typeDef.value.len;u++)s(c.typeDef.value.typeParam);break}case"composite":{c.typeDef.value.forEach(u=>{s(u.ty)});break}case"tuple":{c.typeDef.value.forEach(s);break}case"bitSequence":throw new Error("bitSequence is not supported")}},he=(t,e,n)=>{let o=new Uint8Array;Be(r=>{o=r})(t);const a=new Map;n.forEach((r,i)=>{const c=a.get(r.typeId);c?c.push(i):a.set(r.typeId,[i])});const s=new Set;return e.forEach(r=>{Se(o,r,a,n,s)}),[...s].sort((r,i)=>r-i)},Q=t=>Math.log2(t+1)|0,at=(t,e)=>(t+1>>e)-1;function ot(t,e){const n=e.map(c=>t[c]),o=t.length-1,a=e.map(c=>o+c),s=[];if(a.length){const c=Q(a.at(-1)),u=Math.pow(2,c)-1,h=a.findIndex(m=>m>=u);h>0&&(a.unshift(...a.splice(h)),n.unshift(...n.splice(h)))}let r=0;const i=c=>{if(r===a.length){s.push(c);return}const u=a[r];if(u===c){++r;return}const h=Q(c),m=Q(u);if(c!==at(u,m-h)){s.push(c);return}const f=2*c+1;i(f),i(f+1)};return i(0),{leaves:n,leafIdxs:a,proofIdxs:s}}const X=(t,e,n)=>{if(n!=null&&n!==e)throw new Error(`${t} not expected. Received ${n} expected ${e}`)},it=(t,{decimals:e,tokenSymbol:n,...o})=>{var le;const a=nt(t),{ss58Prefix:s,buildDefinition:r}=We(Oe(a));if(s==null)throw new Error("SS58 prefix not found in metadata");X("SS58 prefix",s,o.base58Prefix);const i=(le=a.pallets.find(p=>p.name==="System"))==null?void 0:le.constants.find(p=>p.name==="Version");if(i==null)throw new Error("System.Version constant not found");const{spec_name:c,spec_version:u}=r(i.type).dec(i.value);if(typeof c!="string"||typeof u!="number")throw new Error("Spec name or spec version not found");X("Spec name",c,o.specName),X("Spec version",u,o.specVersion);const h={decimals:e,tokenSymbol:n,specVersion:u,specName:c,base58Prefix:s},m=new Map(a.lookup.map(p=>[p.id,p])),f=Ze(a,m),B=p=>{const{def:{tag:d,value:g}}=m.get(p);if(d==="primitive")return g.tag;if(d!=="composite"&&d!=="tuple"||g.length>1)throw new Error("The provided definition doesn't map to a primitive");return g.length===0?null:B(d==="tuple"?g[0]:g[0].type)},b=p=>{const{def:d}=m.get(p);if(d.tag==="primitive")return{tag:d.value.tag,value:void 0};if(d.tag==="compact"){const g=B(d.value),k=st[g];if(!k)throw new Error("Invalid primitive for Compact");return{tag:k,value:void 0}}return f.has(p)?{tag:"perId",value:f.get(p)}:{tag:"void",value:void 0}},y={version:a.extrinsic.version,addressTy:b(a.extrinsic.address),callTy:b(a.extrinsic.call),signatureTy:b(a.extrinsic.signature),signedExtensions:a.extrinsic.signedExtensions.map(p=>({identifier:p.identifier,includedInExtrinsic:b(p.type),includedInSignedData:b(p.additionalSigned)}))},T=tt(m,f,b,B),x=T.map(Ie.enc);let E;const oe=()=>{if(E)return E;if(!x.length)return E=[new Uint8Array(32).fill(0)];E=new Array(x.length*2-1);let p=x.length-1;for(let d=0;d<x.length;d++)E[p+d]=C(x[d]);for(let d=E.length-2;d>0;d-=2)E[(d-1)/2]=C(R([E[d],E[d+1]]));return E};let G;const De=()=>{if(G)return G;const d={tag:"V1",value:{typeInformationTreeRoot:oe()[0],extrinsicMetadataHash:C(j.enc(y)),...h}};return G=C(Ge.enc(d))},ie=p=>{const d=ot(x,p),g=oe(),k=d.proofIdxs.map(N=>g[N]);return R([w.enc(d.leaves.length),...d.leaves,w.enc(d.leafIdxs.length),...d.leafIdxs.map(N=>M.enc(N)),w.enc(k.length),...k,j.enc(y),Ee.enc(h)])},ce=p=>{const d=[y.callTy,...y.signedExtensions.map(g=>g.includedInExtrinsic),...y.signedExtensions.map(g=>g.includedInSignedData)];return ie(he(p,d,T))};return{digest:De,getProofForExtrinsic:(p,d)=>{let[,{version:g,signed:k},N]=Ye(p);if(g!==y.version)throw new Error("Incorrect extrinsic version");const ue=k?[y.addressTy,y.signatureTy,...y.signedExtensions.map(J=>J.includedInExtrinsic),y.callTy]:[y.callTy];return d&&(N=R([N,ge(d)]),ue.push(...y.signedExtensions.map(J=>J.includedInSignedData))),ie(he(N,ue,T))},getProofForExtrinsicParts:(p,d,g)=>{const k=R([p,d,g].map(ge));return ce(k)},getProofForExtrinsicPayload:ce}},ct=t=>{try{const{metadata:e}=we(t);if(e.tag!=="v15")throw new Error("Wrong metadata version");return e.value}catch(e){throw e||new Error("Unable to decode metadata")}},be=249,ee={getAddress:1,signTx:2,signRaw:3},H={init:0,continue:1,end:2,getAddress:0,showAddress:1},Te=0,lt=0;var ke=t=>{throw TypeError(t)},se=(t,e,n)=>e.has(t)||ke("Cannot "+n),P=(t,e,n)=>(se(t,e,"read from private field"),n?n.call(t):e.get(t)),W=(t,e,n)=>e.has(t)?ke("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),Y=(t,e,n,o)=>(se(t,e,"write to private field"),e.set(t,n),n),I=(t,e,n)=>(se(t,e,"access private method"),n),L,F,V,v,re,ae,$,te;const me="CheckMetadataHash",ut=Uint8Array.from([44,0,0,128,98,1,0,128]),dt=Uint8Array.from([0,0,0,128]),O=2147483648,Ae=(t,e)=>{if(!Number.isInteger(t)||t<0||t>=O||!Number.isInteger(e)||e<0||e>=O)throw new Error(`Invalid path segments ${t}, ${e}`);return q(ut,M.enc(O+t),dt,M.enc(O+e))},ye=(t,e)=>`${t}:${e}`;class ht{constructor(e){W(this,v),W(this,L),W(this,F),W(this,V),Y(this,L,e),Y(this,F,new Map)}async appInfo(){const e=Uint8Array.from(await I(this,v,re).call(this,176,1,0,0)),n=pe.fromBytes(e.slice(2,2+e[1])).asText(),o=pe.fromBytes(e.slice(2+e[1]+1,2+e[1]+1+e[2+e[1]])).asText();return{appName:n,appVersion:o}}async deviceId(){return P(this,V)==null?Y(this,V,M.dec((await I(this,v,$).call(this,0,0)).slice(0,4))):P(this,V)}async getPubkey(e,n=0){return await I(this,v,$).call(this,e,n)}async seeAddressInDevice(e,n,o=0){return await I(this,v,$).call(this,n,o,!0,e)}async getPolkadotSigner(e,n,o=0){const a=await I(this,v,$).call(this,n,o);return{publicKey:a,signTx:async(r,i,c)=>{const u=it(c,e),h=u.digest(),m=ct(c);if(m.extrinsic.signedExtensions.find(({identifier:T})=>T===me)==null)throw new Error("No `CheckMetadataHash` sigExt found");const f=[],B=[];m.extrinsic.signedExtensions.map(({identifier:T})=>{if(T===me){f.push(Uint8Array.from([1])),B.push(q(Uint8Array.from([1]),h));return}const x=i[T];if(!x)throw new Error(`Missing ${T} signed extension`);f.push(x.value),B.push(x.additionalSigned)});const b=q(r,...f,...B),y=await I(this,v,te).call(this,n,o,b,u.getProofForExtrinsicPayload(b));return Ke(m,a,y,f,r)},signBytes:ze(async r=>(await I(this,v,te).call(this,n,o,r)).slice(1))}}}L=new WeakMap;F=new WeakMap;V=new WeakMap;v=new WeakSet;re=async function(...t){for(;P(this,L).exchangeBusyPromise;)await P(this,L).exchangeBusyPromise;return await P(this,L).send(...t)};ae=async function(...t){const{appName:e,appVersion:n}=await this.appInfo();if(e!=="Polkadot")throw new Error("Polkadot App is not opened");if(Number.parseInt(n.split(".")[0])<100)throw new Error(`Polkadot App version ${n} not expected`);return await I(this,v,re).call(this,...t)};$=async function(t,e,n,o){const a=ye(t,e);if(!n&&P(this,F).has(a))return P(this,F).get(a);if(o!=null&&(!Number.isInteger(o)||o<0||o>=65536))throw new Error(`Invalid ss58Prefix ${o}`);const s=Buffer.from(q(Ae(t,e),Uint8Array.from(K.enc(o??lt)))),i=Uint8Array.from(await I(this,v,ae).call(this,be,ee.getAddress,n?H.showAddress:H.getAddress,Te,s)).slice(0,32);return P(this,F).set(ye(t,e),i),i};te=async function(t,e,n,o){const a=Ae(t,e),s=[];s.push(Buffer.from(q(a,K.enc(n.length))));const r=o==null?n:q(n,o);let i=0;for(;i<r.length;){const u=Math.min(i+250,r.length);s.push(Buffer.from(r.slice(i,u))),i=u}let c;for(let u=0;u<s.length;u++)c=await I(this,v,ae).call(this,be,o==null?ee.signRaw:ee.signTx,u===0?H.init:u===s.length-1?H.end:H.continue,Te,s[u]);if(c==null)throw null;return Uint8Array.from(c).slice(0,c.length-2)};export{ht as LedgerSigner};
